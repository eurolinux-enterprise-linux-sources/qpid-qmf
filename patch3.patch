diff --git a/qpid/cpp/bindings/qmf2/examples/cpp/Makefile.am b/qpid/cpp/bindings/qmf2/examples/cpp/Makefile.am
index 84207d4..062fbd0 100644
--- a/qpid/cpp/bindings/qmf2/examples/cpp/Makefile.am
+++ b/qpid/cpp/bindings/qmf2/examples/cpp/Makefile.am
@@ -21,7 +21,7 @@ INCLUDE = -I$(top_srcdir)/include
 
 AM_CPPFLAGS = $(INCLUDE)
 
-noinst_PROGRAMS=agent list_agents print_events
+noinst_PROGRAMS=agent event_driven_list_agents list_agents print_events
 
 agent_SOURCES=agent.cpp
 agent_LDADD=$(top_builddir)/src/libqmf2.la
@@ -29,5 +29,8 @@ agent_LDADD=$(top_builddir)/src/libqmf2.la
 list_agents_SOURCES=list_agents.cpp
 list_agents_LDADD=$(top_builddir)/src/libqmf2.la
 
+event_driven_list_agents_SOURCES=event_driven_list_agents.cpp
+event_driven_list_agents_LDADD=$(top_builddir)/src/libqmf2.la
+
 print_events_SOURCES=print_events.cpp
 print_events_LDADD=$(top_builddir)/src/libqmf2.la
diff --git a/qpid/cpp/bindings/qmf2/examples/cpp/event_driven_list_agents.cpp b/qpid/cpp/bindings/qmf2/examples/cpp/event_driven_list_agents.cpp
new file mode 100644
index 0000000..c288aa6
--- /dev/null
+++ b/qpid/cpp/bindings/qmf2/examples/cpp/event_driven_list_agents.cpp
@@ -0,0 +1,107 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+#include <sys/select.h>
+#include <time.h>
+
+#include <qpid/messaging/Connection.h>
+#include <qpid/messaging/Duration.h>
+#include <qmf/Agent.h>
+#include <qmf/ConsoleEvent.h>
+#include <qmf/ConsoleSession.h>
+#include <qpid/types/Variant.h>
+#include "qmf/posix/EventNotifier.h"
+
+#include <string>
+#include <iostream>
+
+using namespace std;
+using namespace qmf;
+using qpid::types::Variant;
+using qpid::messaging::Duration;
+
+int main(int argc, char** argv)
+{
+    string url("localhost");
+    string connectionOptions;
+    string sessionOptions;
+
+    if (argc > 1)
+        url = argv[1];
+    if (argc > 2)
+        connectionOptions = argv[2];
+    if (argc > 3)
+        sessionOptions = argv[3];
+
+    qpid::messaging::Connection connection(url, connectionOptions);
+    connection.open();
+
+    ConsoleSession session(connection, sessionOptions);
+    session.open();
+    session.setAgentFilter("");
+
+    posix::EventNotifier notifier(session);
+
+    int fd(notifier.getHandle());
+    time_t lastUpdate;
+    bool ftl = false;
+
+    time(&lastUpdate);
+
+    while (true) {
+        fd_set rfds;
+        struct timeval tv;
+        int nfds, retval;
+
+        FD_ZERO(&rfds);
+        FD_SET(fd, &rfds);
+        nfds = fd + 1;
+        tv.tv_sec = 10;
+        tv.tv_usec = 0;
+
+        retval = select(nfds, &rfds, NULL, NULL, &tv);
+
+        if (retval > 0 && FD_ISSET(fd, &rfds)) {
+            ConsoleEvent event;
+            while (session.nextEvent(event, Duration::IMMEDIATE)) {
+                string eventType = "";
+                switch(event.getType()) {
+                case CONSOLE_AGENT_ADD:             eventType = "Added"; break;
+                case CONSOLE_AGENT_DEL:             eventType = "Deleted"; break;
+                case CONSOLE_AGENT_RESTART:         eventType = "Restarted"; break;
+                case CONSOLE_AGENT_SCHEMA_UPDATE:   eventType = "Schema Updated"; break;
+                case CONSOLE_AGENT_SCHEMA_RESPONSE: eventType = "Schema Response"; break;
+                case CONSOLE_EVENT:                 eventType = "Event"; break;
+                case CONSOLE_QUERY_RESPONSE:        eventType = "Query Response"; break;
+                case CONSOLE_METHOD_RESPONSE:       eventType = "Method Response"; break;
+                case CONSOLE_EXCEPTION:             eventType = "Exception"; break;
+                case CONSOLE_SUBSCRIBE_ADD:         eventType = "Subscription Added"; break;
+                case CONSOLE_SUBSCRIBE_UPDATE:      eventType = "Subscription Updated"; break;
+                case CONSOLE_SUBSCRIBE_DEL:         eventType = "Subscription Deleted" ; break;
+                case CONSOLE_THREAD_FAILED:         eventType = "Thread Failure"; break;
+                default:                            eventType = "[UNDEFINED]";
+                }
+                cout << "Agent " << eventType << ": " << event.getAgent().getName() << endl;
+            }
+        } else {
+            cout << "No message received within waiting period." << endl;
+        }
+    }
+}
+
diff --git a/qpid/cpp/include/qmf/AgentSession.h b/qpid/cpp/include/qmf/AgentSession.h
index 1eeb252..589d364 100644
--- a/qpid/cpp/include/qmf/AgentSession.h
+++ b/qpid/cpp/include/qmf/AgentSession.h
@@ -71,6 +71,11 @@ namespace qmf {
          *                                    If False: Listen only on the routable direct address
          *    strict-security:{True,False}  - If True:  Cooperate with the broker to enforce strict access control to the network
          *                                  - If False: Operate more flexibly with regard to use of messaging facilities [default]
+         *    max-thread-wait-time:N     - Time (in seconds) the session thread will wait for messages from the network between
+         *                                 periodic background processing passes. [default: 5]
+         *                                 Must not be greater than 'interval'.  Larger numbers will cause fewer wake-ups but will
+         *                                 increase the time it takes to shut down the process.  This setting will not affect the
+         *                                 agent's response time for queries or method invocation.
          */
         QMF_EXTERN AgentSession(qpid::messaging::Connection& conn, const std::string& options="");
 
@@ -183,6 +188,7 @@ namespace qmf {
 #ifndef SWIG
     private:
         friend class qmf::PrivateImplRef<AgentSession>;
+        friend struct AgentSessionImplAccess;
 #endif
     };
 
diff --git a/qpid/cpp/include/qmf/ConsoleSession.h b/qpid/cpp/include/qmf/ConsoleSession.h
index 6008036..022485c 100644
--- a/qpid/cpp/include/qmf/ConsoleSession.h
+++ b/qpid/cpp/include/qmf/ConsoleSession.h
@@ -61,6 +61,10 @@ namespace qmf {
          *                                    If False: Listen only on the routable direct address
          *    strict-security:{True,False}  - If True:  Cooperate with the broker to enforce strict access control to the network
          *                                  - If False: Operate more flexibly with regard to use of messaging facilities [default]
+         *    max-thread-wait-time:N     - Time (in seconds) the session thread will wait for messages from the network between
+         *                                 periodic background processing passes.
+         *                                 Must not be greater than 60.  Larger numbers will cause fewer wake-ups but will
+         *                                 increase the time it takes to shut down the process. [default: 5]
          */
         QMF_EXTERN ConsoleSession(qpid::messaging::Connection& conn, const std::string& options="");
 
@@ -119,6 +123,7 @@ namespace qmf {
 #ifndef SWIG
     private:
         friend class qmf::PrivateImplRef<ConsoleSession>;
+        friend struct ConsoleSessionImplAccess;
 #endif
     };
 
diff --git a/qpid/cpp/include/qmf/DataAddr.h b/qpid/cpp/include/qmf/DataAddr.h
index 63d309c..20c4690 100644
--- a/qpid/cpp/include/qmf/DataAddr.h
+++ b/qpid/cpp/include/qmf/DataAddr.h
@@ -51,6 +51,9 @@ namespace qmf {
         QMF_EXTERN uint32_t getAgentEpoch() const;
         QMF_EXTERN qpid::types::Variant::Map asMap() const;
 
+        QMF_EXTERN bool operator==(const DataAddr&) const;
+        QMF_EXTERN bool operator<(const DataAddr&) const;
+
 #ifndef SWIG
     private:
         friend class qmf::PrivateImplRef<DataAddr>;
diff --git a/qpid/cpp/include/qmf/posix/EventNotifier.h b/qpid/cpp/include/qmf/posix/EventNotifier.h
new file mode 100644
index 0000000..ebc1cb5
--- /dev/null
+++ b/qpid/cpp/include/qmf/posix/EventNotifier.h
@@ -0,0 +1,63 @@
+#ifndef __QMF_POSIX_EVENT_NOTIFIER_H
+#define __QMF_POSIX_EVENT_NOTIFIER_H
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+#include <qmf/ImportExport.h>
+#include "qmf/Handle.h"
+#include "qmf/AgentSession.h"
+#include "qmf/ConsoleSession.h"
+
+namespace qmf {
+
+    class PosixEventNotifierImpl;
+    class PosixEventNotifierImplAccess;
+
+namespace posix {
+
+#ifndef SWIG
+  template <class> class PrivateImplRef;
+#endif
+
+  class QMF_CLASS_EXTERN EventNotifier : public qmf::Handle<qmf::PosixEventNotifierImpl> {
+  public:
+      QMF_EXTERN EventNotifier(PosixEventNotifierImpl* impl = 0);
+      QMF_EXTERN EventNotifier(::qmf::AgentSession& agentSession);
+      QMF_EXTERN EventNotifier(::qmf::ConsoleSession& consoleSession);
+      QMF_EXTERN EventNotifier(const EventNotifier& that);
+
+      QMF_EXTERN ~EventNotifier();
+
+      QMF_EXTERN EventNotifier& operator=(const EventNotifier& that);
+
+      QMF_EXTERN int getHandle() const;
+
+#ifndef SWIG
+  private:
+      friend class qmf::PrivateImplRef<EventNotifier>;
+      friend struct qmf::PosixEventNotifierImplAccess;
+#endif
+
+  };
+
+}}
+
+#endif
+
diff --git a/qpid/cpp/include/qpid/framing/FieldTable.h b/qpid/cpp/include/qpid/framing/FieldTable.h
index e8ec524..bdcef6d 100644
--- a/qpid/cpp/include/qpid/framing/FieldTable.h
+++ b/qpid/cpp/include/qpid/framing/FieldTable.h
@@ -65,8 +65,8 @@ class FieldTable
     QPID_COMMON_EXTERN void decode(Buffer& buffer);
 
     QPID_COMMON_EXTERN int count() const;
-    QPID_COMMON_EXTERN size_t size() const { return values.size(); }
-    QPID_COMMON_EXTERN bool empty() { return size() == 0; }
+    QPID_COMMON_INLINE_EXTERN size_t size() const { return values.size(); }
+    QPID_COMMON_INLINE_EXTERN bool empty() { return size() == 0; }
     QPID_COMMON_EXTERN void set(const std::string& name, const ValuePtr& value);
     QPID_COMMON_EXTERN ValuePtr get(const std::string& name) const;
     QPID_COMMON_INLINE_EXTERN bool isSet(const std::string& name) const { return get(name).get() != 0; }
diff --git a/qpid/cpp/managementgen/Makefile.am b/qpid/cpp/managementgen/Makefile.am
index e10dd63..4fc5edc 100644
--- a/qpid/cpp/managementgen/Makefile.am
+++ b/qpid/cpp/managementgen/Makefile.am
@@ -32,6 +32,7 @@ pkgpyexec_qmfgentmpl_PYTHON = \
 	qmfgen/templates/Args.h \
 	qmfgen/templates/Class.cpp \
 	qmfgen/templates/Class.h \
+	qmfgen/templates/CMakeLists.cmake \
 	qmfgen/templates/Event.cpp \
 	qmfgen/templates/Event.h \
 	qmfgen/templates/Makefile.mk \
diff --git a/qpid/cpp/src/CMakeLists.txt b/qpid/cpp/src/CMakeLists.txt
index 80315b9..2986a90 100644
--- a/qpid/cpp/src/CMakeLists.txt
+++ b/qpid/cpp/src/CMakeLists.txt
@@ -1081,7 +1081,7 @@ install (TARGETS qmf OPTIONAL
          COMPONENT ${QPID_COMPONENT_QMF})
 install_pdb (qmf ${QPID_COMPONENT_QMF})
 
-if(NOT WIN32)
+#if(NOT WIN32)
     set (qmf2_HEADERS
         ../include/qmf/AgentEvent.h
         ../include/qmf/Agent.h
@@ -1093,6 +1093,7 @@ if(NOT WIN32)
         ../include/qmf/exceptions.h
         ../include/qmf/Handle.h
         ../include/qmf/ImportExport.h
+        ../include/qmf/posix/EventNotifier.h
         ../include/qmf/Query.h
         ../include/qmf/Schema.h
         ../include/qmf/SchemaId.h
@@ -1122,6 +1123,10 @@ if(NOT WIN32)
         qmf/DataAddrImpl.h
         qmf/Data.cpp
         qmf/DataImpl.h
+        qmf/EventNotifierImpl.h
+        qmf/EventNotifierImpl.cpp
+        qmf/PosixEventNotifier.cpp
+        qmf/PosixEventNotifierImpl.cpp
         qmf/exceptions.cpp
         qmf/Expression.cpp
         qmf/Expression.h
@@ -1156,7 +1161,7 @@ if(NOT WIN32)
             DESTINATION ${QPID_INSTALL_INCLUDEDIR}/qmf
             COMPONENT ${QPID_COMPONENT_QMF})
     install_pdb (qmf2 ${QPID_COMPONENT_QMF})
-endif (NOT WIN32)
+#endif (NOT WIN32)
 
 set (qmfengine_SOURCES
      qmf/engine/Agent.cpp
diff --git a/qpid/cpp/src/qmf.mk b/qpid/cpp/src/qmf.mk
index f3462f1..4da8470 100644
--- a/qpid/cpp/src/qmf.mk
+++ b/qpid/cpp/src/qmf.mk
@@ -43,6 +43,7 @@ QMF2_API =				\
   ../include/qmf/ConsoleSession.h	\
   ../include/qmf/DataAddr.h		\
   ../include/qmf/Data.h			\
+  ../include/qmf/posix/EventNotifier.h	\
   ../include/qmf/exceptions.h		\
   ../include/qmf/Handle.h		\
   ../include/qmf/ImportExport.h		\
@@ -104,6 +105,9 @@ libqmf2_la_SOURCES = 		\
   qmf/DataAddrImpl.h		\
   qmf/Data.cpp			\
   qmf/DataImpl.h		\
+  qmf/EventNotifierImpl.cpp	\
+  qmf/PosixEventNotifier.cpp	\
+  qmf/PosixEventNotifierImpl.cpp \
   qmf/exceptions.cpp		\
   qmf/Expression.cpp		\
   qmf/Expression.h		\
diff --git a/qpid/cpp/src/qmf/Agent.cpp b/qpid/cpp/src/qmf/Agent.cpp
index 915f2a1..684f8e4 100644
--- a/qpid/cpp/src/qmf/Agent.cpp
+++ b/qpid/cpp/src/qmf/Agent.cpp
@@ -72,7 +72,7 @@ Schema Agent::getSchema(const SchemaId& s, Duration t) { return impl->getSchema(
 
 AgentImpl::AgentImpl(const std::string& n, uint32_t e, ConsoleSessionImpl& s) :
     name(n), directSubject(n), epoch(e), session(s), touched(true), untouchedCount(0), capability(0),
-    sender(session.directSender), nextCorrelator(1), schemaCache(s.schemaCache)
+    sender(session.directSender), schemaCache(s.schemaCache)
 {
 }
 
@@ -102,12 +102,11 @@ const Variant& AgentImpl::getAttribute(const string& k) const
 ConsoleEvent AgentImpl::query(const Query& query, Duration timeout)
 {
     boost::shared_ptr<SyncContext> context(new SyncContext());
-    uint32_t correlator;
+    uint32_t correlator(session.correlator());
     ConsoleEvent result;
 
     {
         qpid::sys::Mutex::ScopedLock l(lock);
-        correlator = nextCorrelator++;
         contextMap[correlator] = context;
     }
     try {
@@ -151,12 +150,7 @@ ConsoleEvent AgentImpl::query(const string& text, Duration timeout)
 
 uint32_t AgentImpl::queryAsync(const Query& query)
 {
-    uint32_t correlator;
-
-    {
-        qpid::sys::Mutex::ScopedLock l(lock);
-        correlator = nextCorrelator++;
-    }
+    uint32_t correlator(session.correlator());
 
     sendQuery(query, correlator);
     return correlator;
@@ -172,12 +166,11 @@ uint32_t AgentImpl::queryAsync(const string& text)
 ConsoleEvent AgentImpl::callMethod(const string& method, const Variant::Map& args, const DataAddr& addr, Duration timeout)
 {
     boost::shared_ptr<SyncContext> context(new SyncContext());
-    uint32_t correlator;
+    uint32_t correlator(session.correlator());
     ConsoleEvent result;
 
     {
         qpid::sys::Mutex::ScopedLock l(lock);
-        correlator = nextCorrelator++;
         contextMap[correlator] = context;
     }
     try {
@@ -213,12 +206,7 @@ ConsoleEvent AgentImpl::callMethod(const string& method, const Variant::Map& arg
 
 uint32_t AgentImpl::callMethodAsync(const string& method, const Variant::Map& args, const DataAddr& addr)
 {
-    uint32_t correlator;
-
-    {
-        qpid::sys::Mutex::ScopedLock l(lock);
-        correlator = nextCorrelator++;
-    }
+    uint32_t correlator(session.correlator());
 
     sendMethod(method, args, addr, correlator);
     return correlator;
@@ -596,12 +584,7 @@ void AgentImpl::sendMethod(const string& method, const Variant::Map& args, const
 
 void AgentImpl::sendSchemaRequest(const SchemaId& id)
 {
-    uint32_t correlator;
-
-    {
-        qpid::sys::Mutex::ScopedLock l(lock);
-        correlator = nextCorrelator++;
-    }
+    uint32_t correlator(session.correlator());
 
     if (capability >= AGENT_CAPABILITY_V2_SCHEMA) {
         Query query(QUERY_SCHEMA, id);
diff --git a/qpid/cpp/src/qmf/AgentImpl.h b/qpid/cpp/src/qmf/AgentImpl.h
index 7fa4f43..09754a3 100644
--- a/qpid/cpp/src/qmf/AgentImpl.h
+++ b/qpid/cpp/src/qmf/AgentImpl.h
@@ -99,7 +99,6 @@ namespace qmf {
         uint32_t capability;
         qpid::messaging::Sender sender;
         qpid::types::Variant::Map attributes;
-        uint32_t nextCorrelator;
         std::map<uint32_t, boost::shared_ptr<SyncContext> > contextMap;
         boost::shared_ptr<SchemaCache> schemaCache;
         mutable std::set<std::string> packageSet;
diff --git a/qpid/cpp/src/qmf/AgentSession.cpp b/qpid/cpp/src/qmf/AgentSession.cpp
index 71d3693..251c25f 100644
--- a/qpid/cpp/src/qmf/AgentSession.cpp
+++ b/qpid/cpp/src/qmf/AgentSession.cpp
@@ -19,133 +19,7 @@
  *
  */
 
-#include "qpid/RefCounted.h"
-#include "qmf/PrivateImplRef.h"
-#include "qmf/exceptions.h"
-#include "qmf/AgentSession.h"
-#include "qmf/AgentEventImpl.h"
-#include "qmf/SchemaIdImpl.h"
-#include "qmf/SchemaImpl.h"
-#include "qmf/DataAddrImpl.h"
-#include "qmf/DataImpl.h"
-#include "qmf/QueryImpl.h"
-#include "qmf/agentCapability.h"
-#include "qmf/constants.h"
-#include "qpid/sys/Mutex.h"
-#include "qpid/sys/Condition.h"
-#include "qpid/sys/Thread.h"
-#include "qpid/sys/Runnable.h"
-#include "qpid/log/Statement.h"
-#include "qpid/messaging/Connection.h"
-#include "qpid/messaging/Session.h"
-#include "qpid/messaging/Receiver.h"
-#include "qpid/messaging/Sender.h"
-#include "qpid/messaging/Message.h"
-#include "qpid/messaging/AddressParser.h"
-#include "qpid/management/Buffer.h"
-#include <queue>
-#include <map>
-#include <set>
-#include <iostream>
-#include <memory>
-
-using namespace std;
-using namespace qpid::messaging;
-using namespace qmf;
-using qpid::types::Variant;
-
-namespace qmf {
-    class AgentSessionImpl : public virtual qpid::RefCounted, public qpid::sys::Runnable {
-    public:
-        ~AgentSessionImpl();
-
-        //
-        // Methods from API handle
-        //
-        AgentSessionImpl(Connection& c, const string& o);
-        void setDomain(const string& d) { checkOpen(); domain = d; }
-        void setVendor(const string& v) { checkOpen(); attributes["_vendor"] = v; }
-        void setProduct(const string& p) { checkOpen(); attributes["_product"] = p; }
-        void setInstance(const string& i) { checkOpen(); attributes["_instance"] = i; }
-        void setAttribute(const string& k, const qpid::types::Variant& v) { checkOpen(); attributes[k] = v; }
-        const string& getName() const { return agentName; }
-        void open();
-        void close();
-        bool nextEvent(AgentEvent& e, Duration t);
-        int pendingEvents() const;
-
-        void registerSchema(Schema& s);
-        DataAddr addData(Data& d, const string& n, bool persist);
-        void delData(const DataAddr&);
-
-        void authAccept(AgentEvent& e);
-        void authReject(AgentEvent& e, const string& m);
-        void raiseException(AgentEvent& e, const string& s);
-        void raiseException(AgentEvent& e, const Data& d);
-        void response(AgentEvent& e, const Data& d);
-        void complete(AgentEvent& e);
-        void methodSuccess(AgentEvent& e);
-        void raiseEvent(const Data& d);
-        void raiseEvent(const Data& d, int s);
-
-    private:
-        typedef map<DataAddr, Data, DataAddrCompare> DataIndex;
-        typedef map<SchemaId, Schema, SchemaIdCompare> SchemaMap;
-
-        mutable qpid::sys::Mutex lock;
-        qpid::sys::Condition cond;
-        Connection connection;
-        Session session;
-        Sender directSender;
-        Sender topicSender;
-        string domain;
-        Variant::Map attributes;
-        Variant::Map options;
-        string agentName;
-        bool opened;
-        queue<AgentEvent> eventQueue;
-        qpid::sys::Thread* thread;
-        bool threadCanceled;
-        uint32_t bootSequence;
-        uint32_t interval;
-        uint64_t lastHeartbeat;
-        uint64_t lastVisit;
-        bool forceHeartbeat;
-        bool externalStorage;
-        bool autoAllowQueries;
-        bool autoAllowMethods;
-        uint32_t maxSubscriptions;
-        uint32_t minSubInterval;
-        uint32_t subLifetime;
-        bool publicEvents;
-        bool listenOnDirect;
-        bool strictSecurity;
-        uint64_t schemaUpdateTime;
-        string directBase;
-        string topicBase;
-
-        SchemaMap schemata;
-        DataIndex globalIndex;
-        map<SchemaId, DataIndex, SchemaIdCompareNoHash> schemaIndex;
-
-        void checkOpen();
-        void setAgentName();
-        void enqueueEvent(const AgentEvent&);
-        void handleLocateRequest(const Variant::List& content, const Message& msg);
-        void handleMethodRequest(const Variant::Map& content, const Message& msg);
-        void handleQueryRequest(const Variant::Map& content, const Message& msg);
-        void handleSchemaRequest(AgentEvent&);
-        void handleV1SchemaRequest(qpid::management::Buffer&, uint32_t, const Message&);
-        void dispatch(Message);
-        void sendHeartbeat();
-        void send(Message, const Address&);
-        void flushResponses(AgentEvent&, bool);
-        void periodicProcessing(uint64_t);
-        void run();
-    };
-}
-
-typedef qmf::PrivateImplRef<AgentSession> PI;
+#include "qmf/AgentSessionImpl.h"
 
 AgentSession::AgentSession(AgentSessionImpl* impl) { PI::ctor(*this, impl); }
 AgentSession::AgentSession(const AgentSession& s) : qmf::Handle<AgentSessionImpl>() { PI::copy(*this, s); }
@@ -181,11 +55,11 @@ void AgentSession::raiseEvent(const Data& d, int s) { impl->raiseEvent(d, s); }
 //========================================================================================
 
 AgentSessionImpl::AgentSessionImpl(Connection& c, const string& options) :
-    connection(c), domain("default"), opened(false), thread(0), threadCanceled(false),
+    connection(c), domain("default"), opened(false), eventNotifier(0), thread(0), threadCanceled(false),
     bootSequence(1), interval(60), lastHeartbeat(0), lastVisit(0), forceHeartbeat(false),
     externalStorage(false), autoAllowQueries(true), autoAllowMethods(true),
     maxSubscriptions(64), minSubInterval(3000), subLifetime(300), publicEvents(true),
-    listenOnDirect(true), strictSecurity(false),
+    listenOnDirect(true), strictSecurity(false), maxThreadWaitTime(5),
     schemaUpdateTime(uint64_t(qpid::sys::Duration(qpid::sys::EPOCH, qpid::sys::now())))
 {
     //
@@ -246,7 +120,14 @@ AgentSessionImpl::AgentSessionImpl(Connection& c, const string& options) :
         iter = optMap.find("strict-security");
         if (iter != optMap.end())
             strictSecurity = iter->second.asBool();
+
+        iter = optMap.find("max-thread-wait-time");
+        if (iter != optMap.end())
+            maxThreadWaitTime = iter->second.asUint32();
     }
+
+    if (maxThreadWaitTime > interval)
+        maxThreadWaitTime = interval;
 }
 
 
@@ -254,6 +135,11 @@ AgentSessionImpl::~AgentSessionImpl()
 {
     if (opened)
         close();
+
+    if (thread) {
+        thread->join();
+        delete thread;
+    }
 }
 
 
@@ -262,6 +148,12 @@ void AgentSessionImpl::open()
     if (opened)
         throw QmfException("The session is already open");
 
+    // If the thread exists, join and delete it before creating a new one.
+    if (thread) {
+        thread->join();
+        delete thread;
+    }
+
     const string addrArgs(";{create:never,node:{type:topic}}");
     const string routableAddr("direct-agent.route." + qpid::types::Uuid(true).str());
     attributes["_direct_subject"] = routableAddr;
@@ -299,34 +191,47 @@ void AgentSessionImpl::open()
 }
 
 
-void AgentSessionImpl::close()
+void AgentSessionImpl::closeAsync()
 {
     if (!opened)
         return;
 
-    // Stop and join the receiver thread
+    // Stop the receiver thread.  Don't join it until the destructor is called or open() is called.
     threadCanceled = true;
-    thread->join();
-    delete thread;
-
-    // Close the AMQP session
-    session.close();
     opened = false;
 }
 
 
+void AgentSessionImpl::close()
+{
+    closeAsync();
+
+    if (thread) {
+        thread->join();
+        delete thread;
+        thread = 0;
+    }
+}
+
+
 bool AgentSessionImpl::nextEvent(AgentEvent& event, Duration timeout)
 {
     uint64_t milliseconds = timeout.getMilliseconds();
     qpid::sys::Mutex::ScopedLock l(lock);
 
-    if (eventQueue.empty() && milliseconds > 0)
-        cond.wait(lock, qpid::sys::AbsTime(qpid::sys::now(),
-                                           qpid::sys::Duration(milliseconds * qpid::sys::TIME_MSEC)));
+    if (eventQueue.empty() && milliseconds > 0) {
+        int64_t nsecs(qpid::sys::TIME_INFINITE);
+        if ((uint64_t)(nsecs / 1000000) > milliseconds)
+            nsecs = (int64_t) milliseconds * 1000000;
+        qpid::sys::Duration then(nsecs);
+        cond.wait(lock, qpid::sys::AbsTime(qpid::sys::now(), then));
+    }
 
     if (!eventQueue.empty()) {
         event = eventQueue.front();
         eventQueue.pop();
+        if (eventQueue.empty())
+            alertEventNotifierLH(false);
         return true;
     }
 
@@ -341,6 +246,19 @@ int AgentSessionImpl::pendingEvents() const
 }
 
 
+void AgentSessionImpl::setEventNotifier(EventNotifierImpl* notifier)
+{
+    qpid::sys::Mutex::ScopedLock l(lock);
+    eventNotifier = notifier;
+}
+
+EventNotifierImpl* AgentSessionImpl::getEventNotifier() const
+{
+    qpid::sys::Mutex::ScopedLock l(lock);
+    return eventNotifier;
+}
+
+
 void AgentSessionImpl::registerSchema(Schema& schema)
 {
     if (!schema.isFinalized())
@@ -596,8 +514,10 @@ void AgentSessionImpl::enqueueEvent(const AgentEvent& event)
     qpid::sys::Mutex::ScopedLock l(lock);
     bool notify = eventQueue.empty();
     eventQueue.push(event);
-    if (notify)
+    if (notify) {
         cond.notify();
+        alertEventNotifierLH(true);
+    }
 }
 
 
@@ -1041,6 +961,13 @@ void AgentSessionImpl::periodicProcessing(uint64_t seconds)
 }
 
 
+void AgentSessionImpl::alertEventNotifierLH(bool readable)
+{
+    if (eventNotifier)
+        eventNotifier->setReadable(readable);
+}
+
+
 void AgentSessionImpl::run()
 {
     QPID_LOG(debug, "AgentSession thread started for agent " << agentName);
@@ -1050,7 +977,7 @@ void AgentSessionImpl::run()
             periodicProcessing((uint64_t) qpid::sys::Duration(qpid::sys::EPOCH, qpid::sys::now()) / qpid::sys::TIME_SEC);
 
             Receiver rx;
-            bool valid = session.nextReceiver(rx, Duration::SECOND);
+            bool valid = session.nextReceiver(rx, Duration::SECOND * maxThreadWaitTime);
             if (threadCanceled)
                 break;
             if (valid) {
@@ -1067,6 +994,19 @@ void AgentSessionImpl::run()
         enqueueEvent(AgentEvent(new AgentEventImpl(AGENT_THREAD_FAILED)));
     }
 
+    session.close();
     QPID_LOG(debug, "AgentSession thread exiting for agent " << agentName);
 }
 
+
+AgentSessionImpl& AgentSessionImplAccess::get(AgentSession& session)
+{
+    return *session.impl;
+}
+
+
+const AgentSessionImpl& AgentSessionImplAccess::get(const AgentSession& session)
+{
+    return *session.impl;
+}
+
diff --git a/qpid/cpp/src/qmf/AgentSessionImpl.h b/qpid/cpp/src/qmf/AgentSessionImpl.h
new file mode 100644
index 0000000..9039a59
--- /dev/null
+++ b/qpid/cpp/src/qmf/AgentSessionImpl.h
@@ -0,0 +1,176 @@
+#ifndef __QMF_AGENT_SESSION_IMPL_H
+#define __QMF_AGENT_SESSION_IMPL_H
+
+/*
+ *
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ *
+ */
+
+#include "qpid/RefCounted.h"
+#include "qmf/PrivateImplRef.h"
+#include "qmf/exceptions.h"
+#include "qmf/AgentSession.h"
+#include "qmf/AgentEventImpl.h"
+#include "qmf/EventNotifierImpl.h"
+#include "qpid/messaging/Connection.h"
+#include "qpid/sys/Runnable.h"
+#include "qpid/sys/Mutex.h"
+#include "qpid/sys/Condition.h"
+#include "qpid/sys/Thread.h"
+#include "qpid/sys/Runnable.h"
+#include "qpid/log/Statement.h"
+#include "qpid/messaging/Connection.h"
+#include "qpid/messaging/Session.h"
+#include "qpid/messaging/Receiver.h"
+#include "qpid/messaging/Sender.h"
+#include "qpid/messaging/Message.h"
+#include "qpid/messaging/AddressParser.h"
+#include "qpid/management/Buffer.h"
+#include "qpid/RefCounted.h"
+#include "qmf/PrivateImplRef.h"
+#include "qmf/AgentSession.h"
+#include "qmf/exceptions.h"
+#include "qmf/AgentSession.h"
+#include "qmf/SchemaIdImpl.h"
+#include "qmf/SchemaImpl.h"
+#include "qmf/DataAddrImpl.h"
+#include "qmf/DataImpl.h"
+#include "qmf/QueryImpl.h"
+#include "qmf/agentCapability.h"
+#include "qmf/constants.h"
+
+#include <queue>
+#include <map>
+#include <iostream>
+#include <memory>
+
+using namespace std;
+using namespace qpid::messaging;
+using namespace qmf;
+using qpid::types::Variant;
+using namespace boost;
+
+typedef qmf::PrivateImplRef<AgentSession> PI;
+
+namespace qmf {
+    class AgentSessionImpl : public virtual qpid::RefCounted, public qpid::sys::Runnable {
+    public:
+        ~AgentSessionImpl();
+
+        //
+        // Methods from API handle
+        //
+        AgentSessionImpl(Connection& c, const string& o);
+        void setDomain(const string& d) { checkOpen(); domain = d; }
+        void setVendor(const string& v) { checkOpen(); attributes["_vendor"] = v; }
+        void setProduct(const string& p) { checkOpen(); attributes["_product"] = p; }
+        void setInstance(const string& i) { checkOpen(); attributes["_instance"] = i; }
+        void setAttribute(const string& k, const qpid::types::Variant& v) { checkOpen(); attributes[k] = v; }
+        const string& getName() const { return agentName; }
+        void open();
+        void closeAsync();
+        void close();
+        bool nextEvent(AgentEvent& e, Duration t);
+        int pendingEvents() const;
+
+        void setEventNotifier(EventNotifierImpl* eventNotifier);
+        EventNotifierImpl* getEventNotifier() const;
+
+        void registerSchema(Schema& s);
+        DataAddr addData(Data& d, const string& n, bool persist);
+        void delData(const DataAddr&);
+
+        void authAccept(AgentEvent& e);
+        void authReject(AgentEvent& e, const string& m);
+        void raiseException(AgentEvent& e, const string& s);
+        void raiseException(AgentEvent& e, const Data& d);
+        void response(AgentEvent& e, const Data& d);
+        void complete(AgentEvent& e);
+        void methodSuccess(AgentEvent& e);
+        void raiseEvent(const Data& d);
+        void raiseEvent(const Data& d, int s);
+
+    private:
+        typedef map<DataAddr, Data, DataAddrCompare> DataIndex;
+        typedef map<SchemaId, Schema, SchemaIdCompare> SchemaMap;
+
+        mutable qpid::sys::Mutex lock;
+        qpid::sys::Condition cond;
+        Connection connection;
+        Session session;
+        Sender directSender;
+        Sender topicSender;
+        string domain;
+        Variant::Map attributes;
+        Variant::Map options;
+        string agentName;
+        bool opened;
+        queue<AgentEvent> eventQueue;
+        EventNotifierImpl* eventNotifier;
+        qpid::sys::Thread* thread;
+        bool threadCanceled;
+        uint32_t bootSequence;
+        uint32_t interval;
+        uint64_t lastHeartbeat;
+        uint64_t lastVisit;
+        bool forceHeartbeat;
+        bool externalStorage;
+        bool autoAllowQueries;
+        bool autoAllowMethods;
+        uint32_t maxSubscriptions;
+        uint32_t minSubInterval;
+        uint32_t subLifetime;
+        bool publicEvents;
+        bool listenOnDirect;
+        bool strictSecurity;
+        uint32_t maxThreadWaitTime;
+        uint64_t schemaUpdateTime;
+        string directBase;
+        string topicBase;
+
+        SchemaMap schemata;
+        DataIndex globalIndex;
+        map<SchemaId, DataIndex, SchemaIdCompareNoHash> schemaIndex;
+
+        void checkOpen();
+        void setAgentName();
+        void enqueueEvent(const AgentEvent&);
+        void alertEventNotifierLH(bool readable);
+        void handleLocateRequest(const Variant::List& content, const Message& msg);
+        void handleMethodRequest(const Variant::Map& content, const Message& msg);
+        void handleQueryRequest(const Variant::Map& content, const Message& msg);
+        void handleSchemaRequest(AgentEvent&);
+        void handleV1SchemaRequest(qpid::management::Buffer&, uint32_t, const Message&);
+        void dispatch(Message);
+        void sendHeartbeat();
+        void send(Message, const Address&);
+        void flushResponses(AgentEvent&, bool);
+        void periodicProcessing(uint64_t);
+        void run();
+    };
+
+    struct AgentSessionImplAccess {
+        static AgentSessionImpl& get(AgentSession& session);
+        static const AgentSessionImpl& get(const AgentSession& session);
+    };
+}
+
+
+#endif
+
diff --git a/qpid/cpp/src/qmf/ConsoleSession.cpp b/qpid/cpp/src/qmf/ConsoleSession.cpp
index 5df0d83..2dfc894 100644
--- a/qpid/cpp/src/qmf/ConsoleSession.cpp
+++ b/qpid/cpp/src/qmf/ConsoleSession.cpp
@@ -66,9 +66,9 @@ Subscription ConsoleSession::subscribe(const string& q, const string& f, const s
 //========================================================================================
 
 ConsoleSessionImpl::ConsoleSessionImpl(Connection& c, const string& options) :
-    connection(c), domain("default"), maxAgentAgeMinutes(5), listenOnDirect(true), strictSecurity(false),
-    opened(false), thread(0), threadCanceled(false), lastVisit(0), lastAgePass(0),
-    connectedBrokerInAgentList(false), schemaCache(new SchemaCache())
+    connection(c), domain("default"), maxAgentAgeMinutes(5), listenOnDirect(true), strictSecurity(false), maxThreadWaitTime(5),
+    opened(false), eventNotifier(0), thread(0), threadCanceled(false), lastVisit(0), lastAgePass(0),
+    connectedBrokerInAgentList(false), schemaCache(new SchemaCache()), nextCorrelator(1)
 {
     if (!options.empty()) {
         qpid::messaging::AddressParser parser(options);
@@ -92,7 +92,14 @@ ConsoleSessionImpl::ConsoleSessionImpl(Connection& c, const string& options) :
         iter = optMap.find("strict-security");
         if (iter != optMap.end())
             strictSecurity = iter->second.asBool();
+
+        iter = optMap.find("max-thread-wait-time");
+        if (iter != optMap.end())
+            maxThreadWaitTime = iter->second.asUint32();
     }
+
+    if (maxThreadWaitTime > 60)
+        maxThreadWaitTime = 60;
 }
 
 
@@ -100,6 +107,11 @@ ConsoleSessionImpl::~ConsoleSessionImpl()
 {
     if (opened)
         close();
+
+    if (thread) {
+        thread->join();
+        delete thread;
+    }
 }
 
 
@@ -154,6 +166,12 @@ void ConsoleSessionImpl::open()
     if (opened)
         throw QmfException("The session is already open");
 
+    // If the thread exists, join and delete it before creating a new one.
+    if (thread) {
+        thread->join();
+        delete thread;
+    }
+
     // Establish messaging addresses
     directBase = "qmf." + domain + ".direct";
     topicBase = "qmf." + domain + ".topic";
@@ -182,45 +200,57 @@ void ConsoleSessionImpl::open()
 
     // Start the receiver thread
     threadCanceled = false;
+    opened = true;
     thread = new qpid::sys::Thread(*this);
 
     // Send an agent_locate to direct address 'broker' to identify the connected-broker-agent.
     sendBrokerLocate();
     if (agentQuery)
         sendAgentLocate();
-
-    opened = true;
 }
 
 
-void ConsoleSessionImpl::close()
+void ConsoleSessionImpl::closeAsync()
 {
     if (!opened)
         throw QmfException("The session is already closed");
 
-    // Stop and join the receiver thread
+    // Stop the receiver thread.  Don't join it until the destructor is called or open() is called.
     threadCanceled = true;
-    thread->join();
-    delete thread;
-
-    // Close the AMQP session
-    session.close();
     opened = false;
 }
 
 
+void ConsoleSessionImpl::close()
+{
+    closeAsync();
+
+    if (thread) {
+        thread->join();
+        delete thread;
+        thread = 0;
+    }
+}
+
+
 bool ConsoleSessionImpl::nextEvent(ConsoleEvent& event, Duration timeout)
 {
     uint64_t milliseconds = timeout.getMilliseconds();
     qpid::sys::Mutex::ScopedLock l(lock);
 
-    if (eventQueue.empty() && milliseconds > 0)
-        cond.wait(lock, qpid::sys::AbsTime(qpid::sys::now(),
-                                           qpid::sys::Duration(milliseconds * qpid::sys::TIME_MSEC)));
+    if (eventQueue.empty() && milliseconds > 0) {
+        int64_t nsecs(qpid::sys::TIME_INFINITE);
+        if ((uint64_t)(nsecs / 1000000) > milliseconds)
+            nsecs = (int64_t) milliseconds * 1000000;
+        qpid::sys::Duration then(nsecs);
+        cond.wait(lock, qpid::sys::AbsTime(qpid::sys::now(), then));
+    }
 
     if (!eventQueue.empty()) {
         event = eventQueue.front();
         eventQueue.pop();
+        if (eventQueue.empty())
+            alertEventNotifierLH(false);
         return true;
     }
 
@@ -235,6 +265,20 @@ int ConsoleSessionImpl::pendingEvents() const
 }
 
 
+void ConsoleSessionImpl::setEventNotifier(EventNotifierImpl* notifier)
+{
+    qpid::sys::Mutex::ScopedLock l(lock);
+    eventNotifier = notifier;
+}
+
+
+EventNotifierImpl* ConsoleSessionImpl::getEventNotifier() const
+{
+    qpid::sys::Mutex::ScopedLock l(lock);
+    return eventNotifier;
+}
+
+
 uint32_t ConsoleSessionImpl::getAgentCount() const
 {
     qpid::sys::Mutex::ScopedLock l(lock);
@@ -276,8 +320,10 @@ void ConsoleSessionImpl::enqueueEventLH(const ConsoleEvent& event)
 {
     bool notify = eventQueue.empty();
     eventQueue.push(event);
-    if (notify)
+    if (notify) {
         cond.notify();
+        alertEventNotifierLH(true);
+    }
 }
 
 
@@ -586,6 +632,13 @@ void ConsoleSessionImpl::periodicProcessing(uint64_t seconds)
 }
 
 
+void ConsoleSessionImpl::alertEventNotifierLH(bool readable)
+{
+    if (eventNotifier)
+        eventNotifier->setReadable(readable);
+}
+
+
 void ConsoleSessionImpl::run()
 {
     QPID_LOG(debug, "ConsoleSession thread started");
@@ -596,7 +649,7 @@ void ConsoleSessionImpl::run()
                                qpid::sys::TIME_SEC);
 
             Receiver rx;
-            bool valid = session.nextReceiver(rx, Duration::SECOND);
+            bool valid = session.nextReceiver(rx, Duration::SECOND * maxThreadWaitTime);
             if (threadCanceled)
                 break;
             if (valid) {
@@ -613,6 +666,18 @@ void ConsoleSessionImpl::run()
         enqueueEvent(ConsoleEvent(new ConsoleEventImpl(CONSOLE_THREAD_FAILED)));
     }
 
+    session.close();
     QPID_LOG(debug, "ConsoleSession thread exiting");
 }
 
+
+ConsoleSessionImpl& ConsoleSessionImplAccess::get(ConsoleSession& session)
+{
+  return *session.impl;
+}
+
+
+const ConsoleSessionImpl& ConsoleSessionImplAccess::get(const ConsoleSession& session)
+{
+  return *session.impl;
+}
diff --git a/qpid/cpp/src/qmf/ConsoleSessionImpl.h b/qpid/cpp/src/qmf/ConsoleSessionImpl.h
index 411b3f0..2f1f631 100644
--- a/qpid/cpp/src/qmf/ConsoleSessionImpl.h
+++ b/qpid/cpp/src/qmf/ConsoleSessionImpl.h
@@ -27,6 +27,7 @@
 #include "qmf/SchemaId.h"
 #include "qmf/Schema.h"
 #include "qmf/ConsoleEventImpl.h"
+#include "qmf/EventNotifierImpl.h"
 #include "qmf/SchemaCache.h"
 #include "qmf/Query.h"
 #include "qpid/sys/Mutex.h"
@@ -41,9 +42,14 @@
 #include "qpid/messaging/Address.h"
 #include "qpid/management/Buffer.h"
 #include "qpid/types/Variant.h"
+
+#include <boost/shared_ptr.hpp>
 #include <map>
 #include <queue>
 
+using namespace boost;
+using namespace std;
+
 namespace qmf {
     class ConsoleSessionImpl : public virtual qpid::RefCounted, public qpid::sys::Runnable {
     public:
@@ -56,9 +62,14 @@ namespace qmf {
         void setDomain(const std::string& d) { domain = d; }
         void setAgentFilter(const std::string& f);
         void open();
+        void closeAsync();
         void close();
         bool nextEvent(ConsoleEvent& e, qpid::messaging::Duration t);
         int pendingEvents() const;
+
+        void setEventNotifier(EventNotifierImpl* notifier);
+        EventNotifierImpl* getEventNotifier() const;
+
         uint32_t getAgentCount() const;
         Agent getAgent(uint32_t i) const;
         Agent getConnectedBrokerAgent() const { return connectedBrokerAgent; }
@@ -76,9 +87,11 @@ namespace qmf {
         uint32_t maxAgentAgeMinutes;
         bool listenOnDirect;
         bool strictSecurity;
+        uint32_t maxThreadWaitTime;
         Query agentQuery;
         bool opened;
         std::queue<ConsoleEvent> eventQueue;
+        EventNotifierImpl* eventNotifier;
         qpid::sys::Thread* thread;
         bool threadCanceled;
         uint64_t lastVisit;
@@ -90,6 +103,8 @@ namespace qmf {
         std::string directBase;
         std::string topicBase;
         boost::shared_ptr<SchemaCache> schemaCache;
+        qpid::sys::Mutex corrlock;
+        uint32_t nextCorrelator;
 
         void enqueueEvent(const ConsoleEvent&);
         void enqueueEventLH(const ConsoleEvent&);
@@ -99,10 +114,17 @@ namespace qmf {
         void handleAgentUpdate(const std::string&, const qpid::types::Variant::Map&, const qpid::messaging::Message&);
         void handleV1SchemaResponse(qpid::management::Buffer&, uint32_t, const qpid::messaging::Message&);
         void periodicProcessing(uint64_t);
+        void alertEventNotifierLH(bool readable);
         void run();
+        uint32_t correlator() { qpid::sys::Mutex::ScopedLock l(corrlock); return nextCorrelator++; }
 
         friend class AgentImpl;
     };
+
+    struct ConsoleSessionImplAccess {
+        static ConsoleSessionImpl& get(ConsoleSession& session);
+        static const ConsoleSessionImpl& get(const ConsoleSession& session);
+    };
 }
 
 #endif
diff --git a/qpid/cpp/src/qmf/DataAddr.cpp b/qpid/cpp/src/qmf/DataAddr.cpp
index fb51d57..d16e120 100644
--- a/qpid/cpp/src/qmf/DataAddr.cpp
+++ b/qpid/cpp/src/qmf/DataAddr.cpp
@@ -36,7 +36,9 @@ DataAddr::~DataAddr() { PI::dtor(*this); }
 DataAddr& DataAddr::operator=(const DataAddr& s) { return PI::assign(*this, s); }
 
 bool DataAddr::operator==(const DataAddr& o) { return *impl == *o.impl; }
+bool DataAddr::operator==(const DataAddr& o) const { return *impl == *o.impl; }
 bool DataAddr::operator<(const DataAddr& o) { return *impl < *o.impl; }
+bool DataAddr::operator<(const DataAddr& o) const { return *impl < *o.impl; }
 
 DataAddr::DataAddr(const qpid::types::Variant::Map& m) { PI::ctor(*this, new DataAddrImpl(m)); }
 DataAddr::DataAddr(const string& n, const string& a, uint32_t e) { PI::ctor(*this, new DataAddrImpl(n, a, e)); }
@@ -45,7 +47,7 @@ const string& DataAddr::getAgentName() const { return impl->getAgentName(); }
 uint32_t DataAddr::getAgentEpoch() const { return impl->getAgentEpoch(); }
 Variant::Map DataAddr::asMap() const { return impl->asMap(); }
 
-bool DataAddrImpl::operator==(const DataAddrImpl& other)
+bool DataAddrImpl::operator==(const DataAddrImpl& other) const
 {
     return
         agentName == other.agentName &&
@@ -54,7 +56,7 @@ bool DataAddrImpl::operator==(const DataAddrImpl& other)
 }
 
 
-bool DataAddrImpl::operator<(const DataAddrImpl& other)
+bool DataAddrImpl::operator<(const DataAddrImpl& other) const
 {
     if (agentName < other.agentName) return true;
     if (agentName > other.agentName) return false;
diff --git a/qpid/cpp/src/qmf/DataAddrImpl.h b/qpid/cpp/src/qmf/DataAddrImpl.h
index 3f9cae9..11d512f 100644
--- a/qpid/cpp/src/qmf/DataAddrImpl.h
+++ b/qpid/cpp/src/qmf/DataAddrImpl.h
@@ -38,8 +38,8 @@ namespace qmf {
         //
         // Methods from API handle
         //
-        bool operator==(const DataAddrImpl&);
-        bool operator<(const DataAddrImpl&);
+        bool operator==(const DataAddrImpl&) const;
+        bool operator<(const DataAddrImpl&) const;
         DataAddrImpl(const qpid::types::Variant::Map&);
         DataAddrImpl(const std::string& _name, const std::string& _agentName, uint32_t _agentEpoch=0) :
             agentName(_agentName), name(_name), agentEpoch(_agentEpoch) {}
diff --git a/qpid/cpp/src/qmf/EventNotifierImpl.cpp b/qpid/cpp/src/qmf/EventNotifierImpl.cpp
new file mode 100644
index 0000000..20114aa
--- /dev/null
+++ b/qpid/cpp/src/qmf/EventNotifierImpl.cpp
@@ -0,0 +1,56 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+#include "qmf/EventNotifierImpl.h"
+#include "qmf/AgentSessionImpl.h"
+#include "qmf/ConsoleSessionImpl.h"
+
+EventNotifierImpl::EventNotifierImpl(AgentSession& agentSession)
+    : readable(false), agent(agentSession)
+{
+    AgentSessionImplAccess::get(agent).setEventNotifier(this);
+}
+
+
+EventNotifierImpl::EventNotifierImpl(ConsoleSession& consoleSession)
+    : readable(false), console(consoleSession)
+{
+    ConsoleSessionImplAccess::get(console).setEventNotifier(this);
+}
+
+
+EventNotifierImpl::~EventNotifierImpl()
+{
+    if (agent.isValid())
+        AgentSessionImplAccess::get(agent).setEventNotifier(NULL);
+    if (console.isValid())
+        ConsoleSessionImplAccess::get(console).setEventNotifier(NULL);
+}
+
+void EventNotifierImpl::setReadable(bool readable)
+{
+    update(readable);
+    this->readable = readable;
+}
+
+
+bool EventNotifierImpl::isReadable() const
+{
+    return this->readable;
+}
diff --git a/qpid/cpp/src/qmf/EventNotifierImpl.h b/qpid/cpp/src/qmf/EventNotifierImpl.h
new file mode 100644
index 0000000..d85f997
--- /dev/null
+++ b/qpid/cpp/src/qmf/EventNotifierImpl.h
@@ -0,0 +1,48 @@
+#ifndef __QMF_EVENT_NOTIFIER_IMPL_H
+#define __QMF_EVENT_NOTIFIER_IMPL_H
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+#include "qmf/AgentSession.h"
+#include "qmf/ConsoleSession.h"
+
+namespace qmf
+{
+    class EventNotifierImpl  {
+    private:
+        bool readable;
+        AgentSession agent;
+        ConsoleSession console;
+
+    public:
+        EventNotifierImpl(AgentSession& agentSession);
+        EventNotifierImpl(ConsoleSession& consoleSession);
+        virtual ~EventNotifierImpl();
+
+        void setReadable(bool readable);
+        bool isReadable() const;
+
+    protected:
+        virtual void update(bool readable) = 0;
+    };
+}
+
+#endif
+
diff --git a/qpid/cpp/src/qmf/PosixEventNotifier.cpp b/qpid/cpp/src/qmf/PosixEventNotifier.cpp
new file mode 100644
index 0000000..a364cc1
--- /dev/null
+++ b/qpid/cpp/src/qmf/PosixEventNotifier.cpp
@@ -0,0 +1,65 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+#include "qmf/posix/EventNotifier.h"
+#include "qmf/PosixEventNotifierImpl.h"
+#include "qmf/PrivateImplRef.h"
+
+using namespace qmf;
+using namespace std;
+
+typedef qmf::PrivateImplRef<posix::EventNotifier> PI;
+
+posix::EventNotifier::EventNotifier(PosixEventNotifierImpl* impl) { PI::ctor(*this, impl); }
+
+posix::EventNotifier::EventNotifier(AgentSession& agentSession)
+{
+    PI::ctor(*this, new PosixEventNotifierImpl(agentSession));
+}
+
+
+posix::EventNotifier::EventNotifier(ConsoleSession& consoleSession)
+{
+    PI::ctor(*this, new PosixEventNotifierImpl(consoleSession));
+}
+
+
+posix::EventNotifier::EventNotifier(const posix::EventNotifier& that)
+    : Handle<PosixEventNotifierImpl>()
+{
+    PI::copy(*this, that);
+}
+
+
+posix::EventNotifier::~EventNotifier()
+{
+    PI::dtor(*this);
+}
+
+posix::EventNotifier& posix::EventNotifier::operator=(const posix::EventNotifier& that)
+{
+    return PI::assign(*this, that);
+}
+
+
+int posix::EventNotifier::getHandle() const
+{
+    return impl->getHandle();
+}
+
diff --git a/qpid/cpp/src/qmf/PosixEventNotifierImpl.cpp b/qpid/cpp/src/qmf/PosixEventNotifierImpl.cpp
new file mode 100644
index 0000000..011dbcc
--- /dev/null
+++ b/qpid/cpp/src/qmf/PosixEventNotifierImpl.cpp
@@ -0,0 +1,112 @@
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+#include "PosixEventNotifierImpl.h"
+#include "qpid/log/Statement.h"
+
+#include <fcntl.h>
+#include <unistd.h>
+#include <errno.h>
+
+#define BUFFER_SIZE 10
+
+using namespace qmf;
+
+PosixEventNotifierImpl::PosixEventNotifierImpl(AgentSession& agentSession)
+    : EventNotifierImpl(agentSession)
+{
+    openHandle();
+}
+
+
+PosixEventNotifierImpl::PosixEventNotifierImpl(ConsoleSession& consoleSession)
+    : EventNotifierImpl(consoleSession)
+{
+    openHandle();
+}
+
+
+PosixEventNotifierImpl::~PosixEventNotifierImpl()
+{
+    closeHandle();
+}
+
+
+void PosixEventNotifierImpl::update(bool readable)
+{
+    char buffer[BUFFER_SIZE];
+
+    if(readable && !this->isReadable()) {
+        if (::write(myHandle, "1", 1) == -1)
+            QPID_LOG(error, "PosixEventNotifierImpl::update write failed: " << errno);
+    }
+    else if(!readable && this->isReadable()) {
+        if (::read(yourHandle, buffer, BUFFER_SIZE) == -1)
+            QPID_LOG(error, "PosixEventNotifierImpl::update read failed: " << errno);
+    }
+}
+
+
+void PosixEventNotifierImpl::openHandle()
+{
+    int pair[2];
+
+    if(::pipe(pair) == -1)
+        throw QmfException("Unable to open event notifier handle.");
+
+    yourHandle = pair[0];
+    myHandle = pair[1];
+
+    int flags;
+
+    flags = ::fcntl(yourHandle, F_GETFL);
+    if((::fcntl(yourHandle, F_SETFL, flags | O_NONBLOCK)) == -1)
+        throw QmfException("Unable to make remote handle non-blocking.");
+
+    flags = ::fcntl(myHandle, F_GETFL);
+    if((::fcntl(myHandle, F_SETFL, flags | O_NONBLOCK)) == -1)
+        throw QmfException("Unable to make local handle non-blocking.");
+}
+
+
+void PosixEventNotifierImpl::closeHandle()
+{
+    if(myHandle > 0) {
+        ::close(myHandle);
+        myHandle = -1;
+    }
+
+    if(yourHandle > 0) {
+        ::close(yourHandle);
+        yourHandle = -1;
+    }
+}
+
+
+PosixEventNotifierImpl& PosixEventNotifierImplAccess::get(posix::EventNotifier& notifier)
+{
+    return *notifier.impl;
+}
+
+
+const PosixEventNotifierImpl& PosixEventNotifierImplAccess::get(const posix::EventNotifier& notifier)
+{
+    return *notifier.impl;
+}
+
diff --git a/qpid/cpp/src/qmf/PosixEventNotifierImpl.h b/qpid/cpp/src/qmf/PosixEventNotifierImpl.h
new file mode 100644
index 0000000..c8a7446
--- /dev/null
+++ b/qpid/cpp/src/qmf/PosixEventNotifierImpl.h
@@ -0,0 +1,61 @@
+#ifndef __QMF_POSIX_EVENT_NOTIFIER_IMPL_H
+#define __QMF_POSIX_EVENT_NOTIFIER_IMPL_H
+
+/*
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing,
+ * software distributed under the License is distributed on an
+ * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+ * KIND, either express or implied.  See the License for the
+ * specific language governing permissions and limitations
+ * under the License.
+ */
+
+#include "qmf/posix/EventNotifier.h"
+#include "qmf/EventNotifierImpl.h"
+#include "qpid/RefCounted.h"
+
+namespace qmf
+{
+    class AgentSession;
+    class ConsoleSession;
+
+    class PosixEventNotifierImpl : public EventNotifierImpl, public virtual qpid::RefCounted
+    {
+    public:
+        PosixEventNotifierImpl(AgentSession& agentSession);
+        PosixEventNotifierImpl(ConsoleSession& consoleSession);
+        virtual ~PosixEventNotifierImpl();
+
+        int getHandle() const { return yourHandle; }
+
+    private:
+        int myHandle;
+        int yourHandle;
+
+        void openHandle();
+        void closeHandle();
+
+    protected:
+        void update(bool readable);
+    };
+
+    struct PosixEventNotifierImplAccess
+    {
+        static PosixEventNotifierImpl& get(posix::EventNotifier& notifier);
+        static const PosixEventNotifierImpl& get(const posix::EventNotifier& notifier);
+    };
+
+}
+
+#endif
+
diff --git a/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp b/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp
index 633401e..f183ff8 100644
--- a/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp
+++ b/qpid/cpp/src/qpid/agent/ManagementAgentImpl.cpp
@@ -1378,13 +1378,26 @@ bool ManagementAgentImpl::ConnectionThread::isSleeping() const
 
 void ManagementAgentImpl::PublishThread::run()
 {
-    uint16_t    totalSleep;
+    uint16_t totalSleep;
+    uint16_t sleepTime;
 
     while (!shutdown) {
         agent.periodicProcessing();
         totalSleep = 0;
-        while (totalSleep++ < agent.getInterval() && !shutdown) {
-            ::sleep(1);
+
+        //
+        // Calculate a sleep time that is no greater than 5 seconds and
+        // no less than 1 second.
+        //
+        sleepTime = agent.getInterval();
+        if (sleepTime > 5)
+            sleepTime = 5;
+        else if (sleepTime == 0)
+            sleepTime = 1;
+
+        while (totalSleep < agent.getInterval() && !shutdown) {
+            ::sleep(sleepTime);
+            totalSleep += sleepTime;
         }
     }
 }
diff --git a/qpid/cpp/src/qpid/messaging/AddressParser.h b/qpid/cpp/src/qpid/messaging/AddressParser.h
index 1635331..c51200c 100644
--- a/qpid/cpp/src/qpid/messaging/AddressParser.h
+++ b/qpid/cpp/src/qpid/messaging/AddressParser.h
@@ -26,13 +26,13 @@
 namespace qpid {
 namespace messaging {
 
-class AddressParser
+class QPID_MESSAGING_CLASS_EXTERN AddressParser
 {
   public:
-    AddressParser(const std::string&);
-    bool parse(Address& address);
-    bool parseMap(qpid::types::Variant::Map& map);
-    bool parseList(qpid::types::Variant::List& list);
+    QPID_MESSAGING_EXTERN AddressParser(const std::string&);
+    QPID_MESSAGING_EXTERN bool parse(Address& address);
+    QPID_MESSAGING_EXTERN bool parseMap(qpid::types::Variant::Map& map);
+    QPID_MESSAGING_EXTERN bool parseList(qpid::types::Variant::List& list);
   private:
     const std::string& input;
     std::string::size_type current;
diff --git a/qpid/cpp/src/qpid/store/StorageProvider.h b/qpid/cpp/src/qpid/store/StorageProvider.h
index bc8d187..d162cc5 100644
--- a/qpid/cpp/src/qpid/store/StorageProvider.h
+++ b/qpid/cpp/src/qpid/store/StorageProvider.h
@@ -54,7 +54,7 @@ struct QueueEntry {
     QueueEntry(uint64_t id, TplStatus tpl = NONE, const std::string& x = "")
         : queueId(id), tplStatus(tpl), xid(x) {}
 
-    bool operator==(const QueueEntry& rhs) {
+    bool operator==(const QueueEntry& rhs) const {
         if (queueId != rhs.queueId) return false;
         if (tplStatus == NONE && rhs.tplStatus == NONE) return true;
         return xid == rhs.xid;
diff --git a/qpid/cpp/src/tests/Qmf2.cpp b/qpid/cpp/src/tests/Qmf2.cpp
index 66c774a..bc263d5 100644
--- a/qpid/cpp/src/tests/Qmf2.cpp
+++ b/qpid/cpp/src/tests/Qmf2.cpp
@@ -23,12 +23,36 @@
 #include "qmf/QueryImpl.h"
 #include "qmf/SchemaImpl.h"
 #include "qmf/exceptions.h"
-
+#include "qpid/messaging/Connection.h"
+#include "qmf/PosixEventNotifierImpl.h"
+#include "qmf/AgentSession.h"
+#include "qmf/AgentSessionImpl.h"
+#include "qmf/ConsoleSession.h"
+#include "qmf/ConsoleSessionImpl.h"
 #include "unit_test.h"
 
+using namespace std;
 using namespace qpid::types;
+using namespace qpid::messaging;
 using namespace qmf;
 
+bool isReadable(int fd)
+{
+    fd_set rfds;
+    struct timeval tv;
+    int nfds, result;
+
+    FD_ZERO(&rfds);
+    FD_SET(fd, &rfds);
+    nfds = fd + 1;
+    tv.tv_sec = 0;
+    tv.tv_usec = 0;
+
+    result = select(nfds, &rfds, NULL, NULL, &tv);
+
+    return result > 0;
+}
+
 namespace qpid {
 namespace tests {
 
@@ -315,6 +339,84 @@ QPID_AUTO_TEST_CASE(testSchema)
     BOOST_CHECK_THROW(method.getArgument(3), QmfException);
 }
 
+QPID_AUTO_TEST_CASE(testAgentSessionEventListener)
+{
+    Connection connection("localhost");
+    AgentSession session(connection, "");
+    posix::EventNotifier notifier(session);
+
+    AgentSessionImpl& sessionImpl = AgentSessionImplAccess::get(session);
+            
+    BOOST_CHECK(sessionImpl.getEventNotifier() != 0);
+}
+
+QPID_AUTO_TEST_CASE(testConsoleSessionEventListener)
+{
+    Connection connection("localhost");
+    ConsoleSession session(connection, "");
+    posix::EventNotifier notifier(session);
+
+    ConsoleSessionImpl& sessionImpl = ConsoleSessionImplAccess::get(session);
+
+    BOOST_CHECK(sessionImpl.getEventNotifier() != 0);
+}
+
+QPID_AUTO_TEST_CASE(testGetHandle)
+{
+    Connection connection("localhost");
+    ConsoleSession session(connection, "");
+    posix::EventNotifier notifier(session);
+
+    BOOST_CHECK(notifier.getHandle() > 0);
+}
+
+QPID_AUTO_TEST_CASE(testSetReadableToFalse)
+{
+    Connection connection("localhost");
+    ConsoleSession session(connection, "");
+    posix::EventNotifier notifier(session);
+    PosixEventNotifierImplAccess::get(notifier).setReadable(false);
+
+    bool readable(isReadable(notifier.getHandle()));
+    BOOST_CHECK(!readable);
+}
+
+QPID_AUTO_TEST_CASE(testSetReadable)
+{
+    Connection connection("localhost");
+    ConsoleSession session(connection, "");
+    posix::EventNotifier notifier(session);
+    PosixEventNotifierImplAccess::get(notifier).setReadable(true);
+
+    bool readable(isReadable(notifier.getHandle()));
+    BOOST_CHECK(readable);
+}
+
+QPID_AUTO_TEST_CASE(testSetReadableMultiple)
+{
+    Connection connection("localhost");
+    ConsoleSession session(connection, "");
+    posix::EventNotifier notifier(session);
+    for (int i = 0; i < 15; i++)
+        PosixEventNotifierImplAccess::get(notifier).setReadable(true);
+    PosixEventNotifierImplAccess::get(notifier).setReadable(false);
+
+    bool readable(isReadable(notifier.getHandle()));
+    BOOST_CHECK(!readable);
+}
+
+QPID_AUTO_TEST_CASE(testDeleteNotifier)
+{
+    Connection connection("localhost");
+    ConsoleSession session(connection, "");
+    ConsoleSessionImpl& sessionImpl = ConsoleSessionImplAccess::get(session);
+    {
+        posix::EventNotifier notifier(session);
+        BOOST_CHECK(sessionImpl.getEventNotifier() != 0);
+    }
+    BOOST_CHECK(sessionImpl.getEventNotifier() == 0);
+}
+
 QPID_AUTO_TEST_SUITE_END()
 
 }} // namespace qpid::tests
